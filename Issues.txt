Issue 1 — Orchestration: preserve canonical intake through graph state (spreadsheet fidelity)
Why

Right now the orchestration graph only carries TripPlan, so canonical-only fields (hotel details, flight prefs, comparable hotels, etc.) get dropped. The spreadsheet filler already supports canonical_plan=..., but the graph never passes it, so the orchestration output is lower fidelity than the CLI/tests.

Scope

Extend orchestration state to carry canonical trip intake (or raw canonical payload) alongside the internal TripPlan.

Ensure spreadsheet generation in orchestration uses canonical_plan when available.

Non-Goals

Building a full human-in-the-loop question/answer intake loop.

Changing the canonical schema itself.

Tasks

- [x] Update TripState (or introduce a new state model) to include canonical_plan (or canonical_payload) in addition to plan.
- [x] Update orchestration graph nodes to pass canonical_plan into fill_travel_spreadsheet(..., canonical_plan=...).
- [x] Update orchestration graph nodes to pass canonical_plan into render_travel_spreadsheet_bytes(..., canonical_plan=...).
- [x] Update orchestration/example.py so when --minimal-json is used it retains canonical data in state (prefer using load_trip_plan_input() rather than ad-hoc conversion).
- [x] Add a regression test that runs run_policy_graph() from a canonical fixture and asserts spreadsheet cells for flight/hotel preferences are populated (e.g., B8/B11 etc., similar to existing spreadsheet tests).

Acceptance Criteria

 When orchestration is run from a canonical intake payload, the produced spreadsheet contains canonical-only mapped fields (flight/hotel preference sections populated).

 Tests prove canonical data is retained and used by orchestration.

 CI passes.

Implementation Notes

Relevant files:

src/travel_plan_permission/orchestration/graph.py

src/travel_plan_permission/orchestration/example.py

src/travel_plan_permission/canonical.py (load_trip_plan_input)

src/travel_plan_permission/policy_api.py (supports canonical_plan=)

Issue 2 — Orchestration: make graph state JSON-serializable (checkpoint-friendly)
Why

Current TripState contains Path and a full TripPlan object. That’s fine for a demo, but it becomes annoying when you want checkpointing, persistence, or tooling that expects JSON-serializable state.

Scope

Make orchestration state safe to serialize via model_dump(mode="json") and json.dumps(...).

Avoid non-JSON-native types in state (Path, raw Decimal/date not encoded, etc.).

Non-Goals

Implementing a persistent checkpointer backend (SQLite/Postgres/etc.) unless it’s needed to validate serialization correctness.

Refactoring the entire policy layer.

Tasks

 Replace Path fields in state with str (or structured artifact metadata objects that serialize cleanly).

 Decide how to represent plan data in state:

Option A: keep TripPlan but ensure dumps are JSON-safe, or

Option B: store plan_json dict + validate/construct TripPlan at node boundaries.

 Ensure canonical intake representation in state is also JSON-safe (dict or pydantic model dump).

 Add a test asserting json.dumps(state.model_dump(mode="json")) succeeds for a “realistic” run.

Acceptance Criteria

 TripState.model_dump(mode="json") produces JSON-serializable output (no TypeError on json.dumps(...)).

 No Path objects or other arbitrary types remain in state.

 CI passes.

Implementation Notes

Relevant files:

src/travel_plan_permission/orchestration/graph.py

tests/python/ (new test file, likely test_orchestration_state_serialization.py)

Issue 3 — CI: actually execute the LangGraph path (not just the fallback)
Why

The current smoke test forces prefer_langgraph=False, so CI never exercises the LangGraph-compiled graph. That means the LangGraph path can silently rot while tests stay green.

Scope

Add a test (or CI job) that installs the orchestration extra and runs the LangGraph path (prefer_langgraph=True).

Non-Goals

Expanding test coverage of every branch and failure mode in the graph.

Introducing heavyweight infrastructure just to run one test.

Tasks

 Add a pytest that does:

pytest.importorskip("langgraph")

runs run_policy_graph(..., prefer_langgraph=True) on a small fixture plan

asserts policy result exists + artifact produced

 Ensure at least one CI run installs .[orchestration] so that test executes (not skipped).

This may require adding a small repo-local workflow OR configuring the reusable CI workflow to include the extra.

 Keep runtime small (smoke-level only).

Acceptance Criteria

 CI contains at least one job that installs the orchestration extra and runs a LangGraph-path test.

 The LangGraph-path test fails if LangGraph compilation/invocation breaks (no “always skipped” outcome).

 CI passes.

Implementation Notes

Relevant files:

pyproject.toml (extras already exist)

.github/workflows/* (may need a small additional workflow if reusable CI can’t be configured)

src/travel_plan_permission/orchestration/graph.py

Issue 4 — Consolidate conversion story (one blessed entry point)
Why

Docs currently reference multiple conversion utilities (trip_plan_from_minimal, canonical_trip_plan_to_model, load_trip_plan_input). That’s survivable today, but it’s how subtle inconsistencies accumulate.

Scope

Choose a single recommended conversion/loading entry point for canonical intake.

Make other helpers either thin wrappers or clearly “advanced/legacy.”

Non-Goals

Removing useful flexibility like allowing overrides (trip_id, origin_city) unless there’s a better replacement.

Tasks

 Designate the blessed API (recommended: load_trip_plan_input() from canonical.py).

 Update trip_plan_from_minimal to be a wrapper around canonical validation + conversion, applying overrides via TripPlan.model_copy(update=...) (or equivalent).

 Update docs (docs/langgraph_quickstart.md) to reference one path, and move the rest into a short “alternatives” note (or deprecate).

 Update orchestration example to use the blessed loader/converter.

 Add/update a test asserting the wrapper and the canonical loader produce consistent results for the same payload.

Acceptance Criteria

 Docs present one primary conversion path for canonical intake.

 The “extra” conversion helpers do not implement separate logic paths (they delegate).

 CLI + orchestration use the same conversion surface.

 CI passes.

Implementation Notes

Relevant files:

src/travel_plan_permission/canonical.py

src/travel_plan_permission/conversion.py

docs/langgraph_quickstart.md

src/travel_plan_permission/orchestration/example.py

Issue 5 — Orchestration outputs: include policy missing-input diagnostics + spreadsheet unfilled mapping report
Why

You already implemented:

policy missing-input diagnostics (policy_lite.diagnose_missing_inputs)

spreadsheet unfilled mapping reporting (UnfilledMappingReport)

…but orchestration doesn’t return these, so LangGraph can’t easily drive “ask next question” behavior or even report what’s missing.

Scope

Add structured diagnostics to orchestration state/results:

missing-input diagnostics for policy evaluation

unfilled mapping entries for spreadsheet generation

Non-Goals

Building the full interactive “ask the next question” loop.

Changing policy rule logic.

Tasks

 Extend TripState to include:

policy_missing_inputs (list/dict, JSON-safe)

unfilled_mapping_report (JSON-safe summary)

 In the policy node:

compute diagnostics and attach to state (using context extraction + diagnose_missing_inputs)

 In the spreadsheet node:

instantiate a UnfilledMappingReport, pass it into spreadsheet fill/render, store a serialized form in state

 Update orchestration example to print/report these diagnostics.

 Add tests that confirm:

diagnostics are present when expected (missing inputs scenario)

mapping report includes missing/invalid entries in a controlled fixture scenario

Acceptance Criteria

 Orchestration returns structured diagnostics for missing policy inputs.

 Orchestration returns a structured report of unfilled spreadsheet mappings.

 These outputs are JSON-serializable and test-covered.

 CI passes.

Implementation Notes

Relevant files:

src/travel_plan_permission/orchestration/graph.py

src/travel_plan_permission/policy_lite.py

src/travel_plan_permission/policy_api.py (UnfilledMappingReport)

tests/python/ (new tests)
