name: Setup API Client
description: |
  Unified setup action for API client dependencies and token load balancer.

  This action:
  1. Installs @octokit/* dependencies at pinned versions
  2. Exports all available tokens to environment variables
  3. Ensures consistent API client setup across ALL workflow jobs

  USAGE: Include this action in EVERY job that makes GitHub API calls:
    - uses: ./.github/actions/setup-api-client
      with:
        secrets: '{{ toJSON(secrets) }}'
        github_token: '{{ secrets.GITHUB_TOKEN }}'

inputs:
  secrets:
    description: 'JSON-encoded secrets object - use toJSON(secrets)'
    required: false
  github_token:
    description: 'Primary GitHub token (from github.token or GITHUB_TOKEN)'
    required: false
  # Individual secrets as fallback for workflows that can't use toJSON(secrets)
  service_bot_pat:
    required: false
  actions_bot_pat:
    required: false
  codespaces_workflows:
    required: false
  owner_pr_pat:
    required: false
  agents_automation_pat:
    required: false
  workflows_app_id:
    required: false
  workflows_app_private_key:
    required: false
  keepalive_app_id:
    required: false
  keepalive_app_private_key:
    required: false
  gh_app_id:
    required: false
  gh_app_private_key:
    required: false
  app_1_id:
    required: false
  app_1_private_key:
    required: false
  app_2_id:
    required: false
  app_2_private_key:
    required: false
  install_dir:
    description: 'Override install directory for node dependencies (defaults to $GITHUB_WORKSPACE/.github/scripts)'
    required: false
  # Configuration options
  skip_deps:
    description: 'Skip npm install (if deps already installed in a prior step)'
    required: false
    default: 'false'
  verbose:
    description: 'Enable verbose logging of token setup'
    required: false
    default: 'false'

outputs:
  token_count:
    description: 'Number of tokens exported to environment'
    value: ${{ steps.export-tokens.outputs.token_count }}
  available_tokens:
    description: 'Comma-separated list of available token names'
    value: ${{ steps.export-tokens.outputs.available_tokens }}

runs:
  using: composite
  steps:
    - name: Install API client dependencies
      if: inputs.skip_deps != 'true'
      shell: bash
      run: |
        set -euo pipefail

        # Use dedicated scripts dir, create if needed
        INSTALL_DIR="${{ inputs.install_dir }}"
        if [ -z "$INSTALL_DIR" ]; then
          INSTALL_DIR="${GITHUB_WORKSPACE}/.github/scripts"
        fi
        mkdir -p "$INSTALL_DIR"

        echo "ðŸ“¦ Installing @octokit dependencies in $INSTALL_DIR..."
        cd "$INSTALL_DIR"

        declare -a VENDORED_ALIAS_DIRS=()

        cleanup_vendor_aliases() {
          if [ "${#VENDORED_ALIAS_DIRS[@]}" -eq 0 ]; then
            return 0
          fi

          local cleanup_dir="$INSTALL_DIR"
          if [ -z "$cleanup_dir" ]; then
            echo "::warning::Install dir is empty, skipping vendored alias cleanup"
            return 0
          fi

          if ! pushd "$cleanup_dir" >/dev/null 2>&1; then
            echo "::warning::Failed to enter install dir \"$cleanup_dir\"; skipping vendored alias cleanup"
            return 0
          fi

          for vendored_alias in "${VENDORED_ALIAS_DIRS[@]}"; do
            if [ -z "$vendored_alias" ]; then
              continue
            fi
            rm -rf -- "$vendored_alias" || true
            local parent_dir
            parent_dir=$(dirname "$vendored_alias")
            # Remove empty parent directories that may have been created for scoped packages
            while [ "$parent_dir" != "." ] && [ "$parent_dir" != "/" ]; do
              rmdir -- "$parent_dir" 2>/dev/null || break
              parent_dir=$(dirname "$parent_dir")
            done
          done

          popd >/dev/null 2>&1 || true
        }

        trap cleanup_vendor_aliases EXIT

        create_vendor_aliases() {
          if [ ! -f "package.json" ]; then
            return 0
          fi

          local alias_tmp
          alias_tmp=$(mktemp)

          local helper_root="${GITHUB_ACTION_PATH:-${GITHUB_WORKSPACE}/.github/actions/setup-api-client}"
          local alias_helper="${helper_root}/create_vendor_aliases.js"
          if [ ! -f "$alias_helper" ]; then
            echo "::error::Missing vendored alias helper: $alias_helper"
            rm -f "$alias_tmp"
            return 1
          fi

          if node "$alias_helper" "$INSTALL_DIR" >"$alias_tmp"; then
            :
          else
            echo "::error::Failed to prepare vendored dependency aliases"
            rm -f "$alias_tmp"
            return 1
          fi

          while IFS= read -r vendored_alias; do
            if [ -z "$vendored_alias" ]; then
              continue
            fi
            VENDORED_ALIAS_DIRS+=("$vendored_alias")
          done <"$alias_tmp"

          rm -f "$alias_tmp"
        }

        create_vendor_aliases

        # Strip unresolvable file: dependencies from package.json so npm install
        # doesn't choke when vendored packages are missing (e.g. sparse checkout
        # that doesn't include node_modules/).  Back up the original first so we
        # can restore it after npm install â€” avoids leaking modified state into
        # downstream steps that expect a clean workspace.
        STRIPPED_PKG_JSON=false
        if [ -f "package.json" ]; then
          node -e '
            const fs = require("fs");
            const path = require("path");
            const raw = fs.readFileSync("package.json", "utf8");
            const pkg = JSON.parse(raw);
            let changed = false;
            for (const section of ["dependencies", "devDependencies"]) {
              if (!pkg[section]) continue;
              for (const [name, spec] of Object.entries(pkg[section])) {
                if (typeof spec === "string" && spec.startsWith("file:")) {
                  const target = path.resolve(spec.slice(5));
                  if (!fs.existsSync(target)) {
                    delete pkg[section][name];
                    changed = true;
                    console.log("::notice::Stripped unresolvable vendored dep: " + name + " (" + spec + ")");
                  }
                }
              }
              if (pkg[section] && Object.keys(pkg[section]).length === 0) {
                delete pkg[section];
              }
            }
            if (changed) {
              fs.copyFileSync("package.json", "package.json.bak");
              fs.writeFileSync("package.json", JSON.stringify(pkg, null, 2) + "\n");
              process.stdout.write("STRIPPED");
            }
          '
          if [ -f "package.json.bak" ]; then
            STRIPPED_PKG_JSON=true
          fi
        fi

        # Vendored packages often ship lifecycle scripts (tshy builds, custom bundlers, etc.)
        # that expect repo-specific tooling. Disable lifecycle scripts globally so npm install
        # never invokes those hooks inside CI.
        export npm_config_ignore_scripts=true

        # Track if we create package.json so we can clean it up
        CREATED_PACKAGE_JSON=false
        if [ ! -f "package.json" ]; then
          echo '{"private":true}' > package.json
          CREATED_PACKAGE_JSON=true
        fi

        # Check if already installed (including lru-cache, a required transitive dep
        # of @octokit/auth-app used for GitHub App token minting).
        if [ -d "node_modules/@octokit/rest" ] && [ -d "node_modules/lru-cache" ]; then
          echo "âœ… @octokit/rest already installed"
        else
          # Snapshot vendored package metadata before npm install.
          # npm may overwrite transitive deps (e.g. minimatch) that are
          # committed as vendored packages with intentional version pins.
          VENDORED_SNAPSHOT=""
          if [ -f "node_modules/minimatch/package.json" ]; then
            VENDORED_SNAPSHOT=$(mktemp -d)
            for pkg_dir in node_modules/*/; do
              if [ -f "${pkg_dir}package.json" ]; then
                pkg_name=$(basename "$pkg_dir")
                mkdir -p "${VENDORED_SNAPSHOT}/${pkg_name}"
                cp "${pkg_dir}package.json" "${VENDORED_SNAPSHOT}/${pkg_name}/package.json"
              fi
            done
            echo "ðŸ“¸ Snapshotted vendored package metadata"
          fi

          # Install with pinned versions for consistency.
          # lru-cache is an explicit transitive dep of @octokit/auth-app required for
          # GitHub App token minting; pin it here so npm always hoists a specific version
          # even if a prior cached node_modules state is missing it.
          #
          # Retry with exponential backoff to survive transient npm registry errors
          # (e.g. 403 Forbidden from CDN/rate-limit on safe-buffer, undici, etc.).
          NPM_PACKAGES=(
            @octokit/rest@20.0.2
            @octokit/plugin-retry@6.0.1
            @octokit/plugin-paginate-rest@9.1.5
            @octokit/auth-app@6.0.3
            lru-cache@10.4.3
          )
          NPM_MAX_RETRIES=3
          NPM_BACKOFF=5  # seconds; doubles each retry (5, 10)
          npm_installed=false

          for (( attempt=1; attempt<=NPM_MAX_RETRIES; attempt++ )); do
            npm_output=$(mktemp)

            if npm install --no-save --location=project "${NPM_PACKAGES[@]}" 2>"$npm_output"; then
              rm -f "$npm_output"
              npm_installed=true
              break
            fi

            npm_err=$(cat "$npm_output")
            rm -f "$npm_output"
            echo "::warning::npm install attempt $attempt/$NPM_MAX_RETRIES failed (see logs)"
            echo "::group::npm stderr (attempt $attempt)"
            echo "$npm_err"
            echo "::endgroup::"

            # On first failure, also try --legacy-peer-deps in case it's a peer dep conflict
            if [ "$attempt" -eq 1 ]; then
              echo "::warning::Retrying with --legacy-peer-deps"
              npm_output=$(mktemp)
              if npm install --no-save --legacy-peer-deps --location=project "${NPM_PACKAGES[@]}" 2>"$npm_output"; then
                rm -f "$npm_output"
                npm_installed=true
                break
              fi
              npm_err_legacy=$(cat "$npm_output")
              rm -f "$npm_output"
              echo "::warning::npm install with --legacy-peer-deps failed (see logs)"
              echo "::group::npm stderr (--legacy-peer-deps)"
              echo "$npm_err_legacy"
              echo "::endgroup::"
            fi

            if [ "$attempt" -lt "$NPM_MAX_RETRIES" ]; then
              echo "::notice::Waiting ${NPM_BACKOFF}s before retry..."
              sleep "$NPM_BACKOFF"
              NPM_BACKOFF=$((NPM_BACKOFF * 2))
            fi
          done

          if [ "$npm_installed" != "true" ]; then
            echo "::error::npm install failed after $NPM_MAX_RETRIES attempts"
            exit 1
          fi

          # Restore vendored package metadata that npm may have overwritten
          if [ -n "${VENDORED_SNAPSHOT:-}" ] && [ -d "${VENDORED_SNAPSHOT}" ]; then
            for pkg_backup in "${VENDORED_SNAPSHOT}"/*/; do
              pkg_name=$(basename "$pkg_backup")
              if [ -f "node_modules/${pkg_name}/package.json" ] && \
                 [ -f "${pkg_backup}package.json" ]; then
                cp "${pkg_backup}package.json" "node_modules/${pkg_name}/package.json"
              fi
            done
            rm -rf "${VENDORED_SNAPSHOT}"
            echo "ðŸ“¸ Restored vendored package metadata"
          fi

          echo "âœ… @octokit dependencies installed"
        fi

        # Restore original package.json if we stripped file: deps earlier,
        # so downstream steps see an unmodified workspace.
        if [ "$STRIPPED_PKG_JSON" = "true" ] && [ -f "package.json.bak" ]; then
          mv "package.json.bak" "package.json"
        fi

        cleanup_vendor_aliases
        trap - EXIT
    - name: Export NODE_PATH for shared deps
      shell: bash
      run: |
        set -euo pipefail
        INSTALL_DIR="${{ inputs.install_dir }}"
        if [ -z "$INSTALL_DIR" ]; then
          INSTALL_DIR="${GITHUB_WORKSPACE}/.github/scripts"
        fi
        if [ -d "${INSTALL_DIR}/node_modules" ]; then
          if [ -n "${NODE_PATH:-}" ]; then
            echo "NODE_PATH=${INSTALL_DIR}/node_modules:${NODE_PATH}" >> "$GITHUB_ENV"
          else
            echo "NODE_PATH=${INSTALL_DIR}/node_modules" >> "$GITHUB_ENV"
          fi
        else
          echo "::notice::setup-api-client: ${INSTALL_DIR}/node_modules not found; skipping NODE_PATH export."
        fi

    - name: Export load balancer tokens
      id: export-tokens
      shell: bash
      env:
        INPUT_SECRETS: ${{ inputs.secrets }}
        INPUT_GITHUB_TOKEN: ${{ inputs.github_token }}
        INPUT_SERVICE_BOT_PAT: ${{ inputs.service_bot_pat }}
        INPUT_ACTIONS_BOT_PAT: ${{ inputs.actions_bot_pat }}
        INPUT_CODESPACES_WORKFLOWS: ${{ inputs.codespaces_workflows }}
        INPUT_OWNER_PR_PAT: ${{ inputs.owner_pr_pat }}
        INPUT_AGENTS_AUTOMATION_PAT: ${{ inputs.agents_automation_pat }}
        INPUT_WORKFLOWS_APP_ID: ${{ inputs.workflows_app_id }}
        INPUT_WORKFLOWS_APP_PRIVATE_KEY: ${{ inputs.workflows_app_private_key }}
        INPUT_KEEPALIVE_APP_ID: ${{ inputs.keepalive_app_id }}
        INPUT_KEEPALIVE_APP_PRIVATE_KEY: ${{ inputs.keepalive_app_private_key }}
        INPUT_GH_APP_ID: ${{ inputs.gh_app_id }}
        INPUT_GH_APP_PRIVATE_KEY: ${{ inputs.gh_app_private_key }}
        INPUT_APP_1_ID: ${{ inputs.app_1_id }}
        INPUT_APP_1_PRIVATE_KEY: ${{ inputs.app_1_private_key }}
        INPUT_APP_2_ID: ${{ inputs.app_2_id }}
        INPUT_APP_2_PRIVATE_KEY: ${{ inputs.app_2_private_key }}
        INPUT_VERBOSE: ${{ inputs.verbose }}
      run: |
        set -euo pipefail

        token_count=0
        available_tokens=""

        # Export a variable to GITHUB_ENV
        # Note: Empty values are intentionally not counted as available tokens
        export_var() {
          local name="$1"
          local value="${2-}"
          if [ -z "${value}" ]; then
            return 0
          fi

          # Handle multiline values (like private keys)
          if [[ "${value}" == *$'\n'* ]]; then
            {
              echo "${name}<<EOF"
              printf '%s\n' "${value}"
              echo "EOF"
            } >>"${GITHUB_ENV}"
          else
            printf '%s=%s\n' "${name}" "${value}" >>"${GITHUB_ENV}"
          fi

          token_count=$((token_count + 1))
          if [ -n "$available_tokens" ]; then
            available_tokens="${available_tokens},${name}"
          else
            available_tokens="${name}"
          fi

          if [ "${INPUT_VERBOSE}" = "true" ]; then
            echo "  âœ… ${name} exported"
          fi
        }

        echo "ðŸ” Exporting tokens to environment..."

        # Try to extract from JSON secrets first (requires jq)
        if [ -n "${INPUT_SECRETS:-}" ] && [ "${INPUT_SECRETS}" != "null" ]; then
          if ! command -v jq >/dev/null 2>&1; then
            echo "::warning::'jq' is not installed; falling back to individual token inputs instead of parsing JSON secrets."
            # Fall back to individual inputs when jq is unavailable
            SERVICE_BOT_PAT="${INPUT_SERVICE_BOT_PAT:-}"
            ACTIONS_BOT_PAT="${INPUT_ACTIONS_BOT_PAT:-}"
            CODESPACES_WORKFLOWS="${INPUT_CODESPACES_WORKFLOWS:-}"
            OWNER_PR_PAT="${INPUT_OWNER_PR_PAT:-}"
            AGENTS_AUTOMATION_PAT="${INPUT_AGENTS_AUTOMATION_PAT:-}"
            WORKFLOWS_APP_ID="${INPUT_WORKFLOWS_APP_ID:-}"
            WORKFLOWS_APP_PRIVATE_KEY="${INPUT_WORKFLOWS_APP_PRIVATE_KEY:-}"
            KEEPALIVE_APP_ID="${INPUT_KEEPALIVE_APP_ID:-}"
            KEEPALIVE_APP_PRIVATE_KEY="${INPUT_KEEPALIVE_APP_PRIVATE_KEY:-}"
            GH_APP_ID="${INPUT_GH_APP_ID:-}"
            GH_APP_PRIVATE_KEY="${INPUT_GH_APP_PRIVATE_KEY:-}"
            APP_1_ID="${INPUT_APP_1_ID:-}"
            APP_1_PRIVATE_KEY="${INPUT_APP_1_PRIVATE_KEY:-}"
            APP_2_ID="${INPUT_APP_2_ID:-}"
            APP_2_PRIVATE_KEY="${INPUT_APP_2_PRIVATE_KEY:-}"
          else
            # Parse JSON secrets using jq
            extract_secret() {
              local key="$1"
              echo "${INPUT_SECRETS}" | jq -r ".${key} // empty" 2>/dev/null || echo ""
            }

            SERVICE_BOT_PAT=$(extract_secret "SERVICE_BOT_PAT")
            ACTIONS_BOT_PAT=$(extract_secret "ACTIONS_BOT_PAT")
            CODESPACES_WORKFLOWS=$(extract_secret "CODESPACES_WORKFLOWS")
            OWNER_PR_PAT=$(extract_secret "OWNER_PR_PAT")
            AGENTS_AUTOMATION_PAT=$(extract_secret "AGENTS_AUTOMATION_PAT")
            WORKFLOWS_APP_ID=$(extract_secret "WORKFLOWS_APP_ID")
            WORKFLOWS_APP_PRIVATE_KEY=$(extract_secret "WORKFLOWS_APP_PRIVATE_KEY")
            KEEPALIVE_APP_ID=$(extract_secret "KEEPALIVE_APP_ID")
            KEEPALIVE_APP_PRIVATE_KEY=$(extract_secret "KEEPALIVE_APP_PRIVATE_KEY")
            GH_APP_ID=$(extract_secret "GH_APP_ID")
            GH_APP_PRIVATE_KEY=$(extract_secret "GH_APP_PRIVATE_KEY")
            APP_1_ID=$(extract_secret "APP_1_ID")
            APP_1_PRIVATE_KEY=$(extract_secret "APP_1_PRIVATE_KEY")
            APP_2_ID=$(extract_secret "APP_2_ID")
            APP_2_PRIVATE_KEY=$(extract_secret "APP_2_PRIVATE_KEY")
          fi
        else
          # Fall back to individual inputs
          SERVICE_BOT_PAT="${INPUT_SERVICE_BOT_PAT:-}"
          ACTIONS_BOT_PAT="${INPUT_ACTIONS_BOT_PAT:-}"
          CODESPACES_WORKFLOWS="${INPUT_CODESPACES_WORKFLOWS:-}"
          OWNER_PR_PAT="${INPUT_OWNER_PR_PAT:-}"
          AGENTS_AUTOMATION_PAT="${INPUT_AGENTS_AUTOMATION_PAT:-}"
          WORKFLOWS_APP_ID="${INPUT_WORKFLOWS_APP_ID:-}"
          WORKFLOWS_APP_PRIVATE_KEY="${INPUT_WORKFLOWS_APP_PRIVATE_KEY:-}"
          KEEPALIVE_APP_ID="${INPUT_KEEPALIVE_APP_ID:-}"
          KEEPALIVE_APP_PRIVATE_KEY="${INPUT_KEEPALIVE_APP_PRIVATE_KEY:-}"
          GH_APP_ID="${INPUT_GH_APP_ID:-}"
          GH_APP_PRIVATE_KEY="${INPUT_GH_APP_PRIVATE_KEY:-}"
          APP_1_ID="${INPUT_APP_1_ID:-}"
          APP_1_PRIVATE_KEY="${INPUT_APP_1_PRIVATE_KEY:-}"
          APP_2_ID="${INPUT_APP_2_ID:-}"
          APP_2_PRIVATE_KEY="${INPUT_APP_2_PRIVATE_KEY:-}"
        fi

        # Export GITHUB_TOKEN (GH_TOKEN is the same value, only count once)
        if [ -n "${INPUT_GITHUB_TOKEN:-}" ]; then
          export_var "GITHUB_TOKEN" "${INPUT_GITHUB_TOKEN}"
          # GH_TOKEN is exported but not double-counted
          printf '%s=%s\n' "GH_TOKEN" "${INPUT_GITHUB_TOKEN}" >>"${GITHUB_ENV}"
        fi

        # Export PATs
        export_var "SERVICE_BOT_PAT" "${SERVICE_BOT_PAT:-}"
        export_var "ACTIONS_BOT_PAT" "${ACTIONS_BOT_PAT:-}"
        export_var "CODESPACES_WORKFLOWS" "${CODESPACES_WORKFLOWS:-}"
        export_var "OWNER_PR_PAT" "${OWNER_PR_PAT:-}"
        export_var "AGENTS_AUTOMATION_PAT" "${AGENTS_AUTOMATION_PAT:-}"

        # Export App credentials
        export_var "WORKFLOWS_APP_ID" "${WORKFLOWS_APP_ID:-}"
        export_var "WORKFLOWS_APP_PRIVATE_KEY" "${WORKFLOWS_APP_PRIVATE_KEY:-}"
        export_var "KEEPALIVE_APP_ID" "${KEEPALIVE_APP_ID:-}"
        export_var "KEEPALIVE_APP_PRIVATE_KEY" "${KEEPALIVE_APP_PRIVATE_KEY:-}"
        export_var "GH_APP_ID" "${GH_APP_ID:-}"
        export_var "GH_APP_PRIVATE_KEY" "${GH_APP_PRIVATE_KEY:-}"
        export_var "APP_1_ID" "${APP_1_ID:-}"
        export_var "APP_1_PRIVATE_KEY" "${APP_1_PRIVATE_KEY:-}"
        export_var "APP_2_ID" "${APP_2_ID:-}"
        export_var "APP_2_PRIVATE_KEY" "${APP_2_PRIVATE_KEY:-}"

        # Output summary
        echo "token_count=${token_count}" >> "$GITHUB_OUTPUT"
        echo "available_tokens=${available_tokens}" >> "$GITHUB_OUTPUT"

        echo ""
        echo "ðŸ“Š Token Setup Summary:"
        echo "  Total tokens exported: ${token_count}"
        if [ "${INPUT_VERBOSE}" = "true" ]; then
          echo "  Available: ${available_tokens}"
        fi

        # Warn if no tokens were exported
        if [ "${token_count}" -eq 0 ]; then
          echo "::warning::No tokens were exported! API calls may fail."
          echo "::warning::Ensure secrets are passed to this action."
        fi
