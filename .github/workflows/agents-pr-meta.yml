# Thin caller for PR meta management - delegates to Workflows repo reusable workflow
# Detects keepalive comments on PRs and dispatches agent continuation
#
# This is the CRITICAL workflow for keepalive to function:
# - Listens for comments on PRs
# - Detects when Codex posts "round complete" markers
# - Dispatches orchestrator to continue agent work
#
# Copy this file to: .github/workflows/agents-pr-meta.yml
#
# Required secrets:
# - SERVICE_BOT_PAT: PAT for stranske-automation-bot
# - ACTIONS_BOT_PAT: PAT for workflow dispatch
# - AGENTS_AUTOMATION_PAT: Alternative PAT for agent automation (optional)
name: Agents PR Meta

on:
  issue_comment:
    types: [created]
  pull_request:
    types: [opened, synchronize, reopened, edited]
  # Re-evaluate keepalive when Gate completes - handles race condition where
  # human comment arrives before Gate finishes
  workflow_run:
    workflows: ["Gate"]
    types: [completed]
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to process'
        required: false
        type: string
      debug:
        description: 'Enable debug logging'
        required: false
        type: boolean
        default: false

permissions:
  actions: write
  checks: read
  contents: read
  issues: write
  pull-requests: write

concurrency:
  group: ${{ github.event_name == 'issue_comment' && format('agents-pr-meta-comment-{0}', github.event.comment.id) || format('agents-pr-meta-run-{0}', github.run_id) }}
  cancel-in-progress: false

jobs:
  # Resolve PR context for issue_comment events
  resolve_pr:
    if: github.event_name == 'issue_comment' && github.event.issue.pull_request
    runs-on: ubuntu-latest
    outputs:
      pr_number: ${{ steps.resolve.outputs.pr_number }}
      comment_id: ${{ steps.resolve.outputs.comment_id }}
      comment_body: ${{ steps.resolve.outputs.comment_body }}
    steps:
      - name: Resolve PR context
        id: resolve
        uses: actions/github-script@v8
        with:
          script: |
            const pr = context.payload.issue;
            const comment = context.payload.comment;
            core.setOutput('pr_number', pr.number);
            core.setOutput('comment_id', comment.id);
            // Encode comment body as Base64 to safely handle multiline and special characters.
            // The reusable workflow at stranske/Workflows/.github/workflows/reusable-20-pr-meta.yml
            // expects this value to be Base64-encoded and is responsible for decoding it.
            core.setOutput('comment_body', Buffer.from(comment.body || '').toString('base64'));

  # Call reusable PR meta workflow for comment events
  pr_meta_comment:
    needs: resolve_pr
    if: github.event_name == 'issue_comment' && github.event.issue.pull_request
    uses: stranske/Workflows/.github/workflows/reusable-20-pr-meta.yml@main
    with:
      pr_number: ${{ fromJSON(needs.resolve_pr.outputs.pr_number) }}
      comment_id: ${{ needs.resolve_pr.outputs.comment_id }}
      comment_body: ${{ needs.resolve_pr.outputs.comment_body }}
      event_name: 'issue_comment'
      event_action: ${{ github.event.action }}
      allowed_keepalive_logins: ${{ vars.ALLOWED_KEEPALIVE_LOGINS || 'stranske' }}
    secrets: inherit

  # Call reusable PR meta workflow for PR events
  pr_meta_pr:
    if: github.event_name == 'pull_request'
    uses: stranske/Workflows/.github/workflows/reusable-20-pr-meta.yml@main
    with:
      pr_number: ${{ github.event.pull_request.number }}
      event_name: 'pull_request'
      event_action: ${{ github.event.action }}
    secrets: inherit

  # Resolve PR from Gate workflow_run event
  resolve_gate_pr:
    if: github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success'
    runs-on: ubuntu-latest
    outputs:
      pr_number: ${{ steps.resolve.outputs.pr_number }}
      should_process: ${{ steps.resolve.outputs.should_process }}
    steps:
      - name: Resolve PR from Gate run
        id: resolve
        uses: actions/github-script@v8
        with:
          script: |
            const run = context.payload.workflow_run;
            const prs = run.pull_requests || [];
            
            if (prs.length === 0) {
              core.info('No PRs associated with Gate run');
              core.setOutput('should_process', 'false');
              return;
            }
            
            // Use the first PR (Gate typically runs on a single PR)
            const prNumber = prs[0].number;
            core.info(`Gate completed for PR #${prNumber}`);
            
            // Check if PR has keepalive label
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            const hasKeepalive = pr.labels.some(l => l.name === 'agents:keepalive');
            if (!hasKeepalive) {
              core.info(`PR #${prNumber} does not have agents:keepalive label`);
              core.setOutput('should_process', 'false');
              return;
            }
            
            core.setOutput('pr_number', prNumber);
            core.setOutput('should_process', 'true');

  # Re-evaluate keepalive when Gate completes successfully
  pr_meta_gate:
    needs: resolve_gate_pr
    if: github.event_name == 'workflow_run' && needs.resolve_gate_pr.outputs.should_process == 'true'
    uses: stranske/Workflows/.github/workflows/reusable-20-pr-meta.yml@main
    with:
      pr_number: ${{ fromJSON(needs.resolve_gate_pr.outputs.pr_number) }}
      event_name: 'workflow_run'
      event_action: 'completed'
      allowed_keepalive_logins: ${{ vars.ALLOWED_KEEPALIVE_LOGINS || 'stranske' }}
      allow_replay: true
    secrets: inherit
